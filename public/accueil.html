<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Accueil - Rasar</title>
    <link rel="stylesheet" href="./accueil.css">
    
    <style>

    </style>
</head>
<body>
    <div class="topbar">
        <div class="left">üë§ <span id="username">utilisateur</span></div>
        <div class="right"><button onclick="logout()">D√©connexion</button></div>
    </div>

    <main>
        <div class="title-rasar">RASAR</div>
        
        <div class="status-container">
            <div id="status">En attente...</div>
            <div class="settings-icon" title="Modifier la connexion">‚úèÔ∏è</div>

            <div class="settings-popup">
                <div style="margin-bottom:10px; font-weight:800; border-bottom:1px solid #eee; padding-bottom:5px;">Param√®tres</div>
                
                <div class="setting-item">
                    <label>Flux MQTT:</label>
                    <button id="btn-connection" class="btn-toggle btn-on" onclick="toggleConnection()">ACTIF</button>
                </div>

                <div class="setting-item">
                    <label>Mode:</label>
                    <select id="connection-mode" onchange="switchMode()">
                        <option value="sse">SSE (Temps r√©el)</option>
                        <option value="poll">Polling (Lent)</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="main-content">
            <div id="sketch"></div>

            <div class="log-sidebar">
                <div class="log-header">MESSAGES RE√áUS</div>
                <div id="log-list" class="log-container">
                    <div class="log-entry" style="color:#888;">En attente de donn√©es...</div>
                </div>
            </div>
        </div>

    </main>

    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
    <script>
        // --- AUTH & SESSION ---
        fetch('/api/check-session')
            .then(response => response.json())
            .then(data => {
                if (!data.authenticated) { window.location.href = '/login.html'; } 
                else { document.getElementById('username').textContent = data.username; }
            })
            .catch(err => { window.location.href = '/login.html'; });

        function logout() { window.location.href = '/login.html'; }

        // --- GESTION LOGS (NOUVEAU) ---
        const logList = document.getElementById('log-list');

        function addLogEntry(data) {
            // Cr√©ation de l'√©l√©ment HTML
            const div = document.createElement('div');
            div.className = 'log-entry';
            
            const time = new Date().toLocaleTimeString();
            // On v√©rifie si c'est un objet ou du texte
            const angle = data.angle !== undefined ? Math.round(data.angle) + '¬∞' : 'N/A';
            const dist = data.distance !== undefined ? Math.round(data.distance) + 'cm' : 'N/A';

            div.innerHTML = `<span class="log-time">[${time}]</span> <span class="log-data">A:${angle} - D:${dist}</span>`;
            
            // Ajout au DOM
            logList.appendChild(div);

            // Scroll automatique vers le bas
            logList.scrollTop = logList.scrollHeight;

            // Limiter le nombre de logs pour ne pas faire laguer le navigateur (max 50)
            if (logList.children.length > 50) {
                logList.removeChild(logList.firstChild);
            }
        }

        // --- GESTION CONNEXION ---
        const statusDiv = document.getElementById('status');
        const btnConnection = document.getElementById('btn-connection');
        const modeSelect = document.getElementById('connection-mode');
        
        let radarQueue = []; 
        let evtSource = null;
        let pollInterval = null;
        let isConnected = false;

        // Fonction pour d√©marrer la connexion selon le mode choisi
        function startConnection() {
            const mode = modeSelect.value;
            
            if (mode === 'sse') {
                if (!!window.EventSource) {
                    if (evtSource) evtSource.close();

                    evtSource = new EventSource('/events');

                    evtSource.onopen = () => {
                        updateStatus('Connect√© (SSE)', true);
                    };

                    evtSource.onerror = (err) => {
                        updateStatus('Erreur SSE', false);
                        console.error('SSE erreur:', err);
                    };

                    evtSource.onmessage = (e) => {
                        if(!isConnected) return;
                        try {
                            const msg = JSON.parse(e.data);
                            const payload = msg.message || msg;
                            radarQueue.push(payload);
                            addLogEntry(payload);
                        } catch (err) { console.error('Erreur parsing', err); }
                    };
                }
            } else {
                // Mode Polling
                if (evtSource) { evtSource.close(); evtSource = null; }
                
                // Fonction fetch imm√©diate
                const doFetch = async () => {
                    if(!isConnected) return;
                    try {
                        const response = await fetch('/api/messages');
                        const messages = await response.json();
                        updateStatus('Connect√© (Polling)', true);
                        if (messages.length > 0) {
                            messages.forEach(m => {
                                const payload = m.message;
                                radarQueue.push(payload);
                                addLogEntry(payload);
                            });
                        }
                    } catch (err) {
                        updateStatus('Erreur Polling', false);
                    }
                };
                
                doFetch();
                pollInterval = setInterval(doFetch, 500);
            }
            
            isConnected = true;
            updateBtnUI(true);
        }

        // Fonction pour tout arr√™ter
        function stopConnection() {
            isConnected = false;
            if (evtSource) {
                evtSource.close();
                evtSource = null;
            }
            if (pollInterval) {
                clearInterval(pollInterval);
                pollInterval = null;
            }
            updateStatus('D√©connect√© (Pause)', false);
            updateBtnUI(false);
        }

        // Toggle Button Click
        function toggleConnection() {
            if (isConnected) {
                stopConnection();
            } else {
                startConnection();
            }
        }

        // Changement de mode (Dropdown)
        function switchMode() {
            if (isConnected) {
                stopConnection();
                startConnection();
            }
        }

        // UI Updates
        function updateStatus(text, active) {
            statusDiv.textContent = text;
            statusDiv.style.color = active ? '#28a745' : '#dc3545';
        }

        function updateBtnUI(active) {
            if(active) {
                btnConnection.textContent = "ACTIF";
                btnConnection.className = "btn-toggle btn-on";
            } else {
                btnConnection.textContent = "INACTIF";
                btnConnection.className = "btn-toggle btn-off";
            }
        }

        // D√©marrage initial
        startConnection();
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
    
    <script>
        // --- VISUALISATION P5.JS (Inchang√©e) ---
        const MAX_RANGE_CM = 300;
        const MAX_RADIUS_PX = 400;
        let x = 450;
        let y = 450;
        let points = [];
        let lastDistance = null;
        let scanAngle = 0;

        function setup() {
            let cnv = createCanvas(900, 450);
            cnv.parent('sketch');
        }

        function draw() {
            background(0, 40);
            drawRadarCircles();
            let processed = 0;
            while (radarQueue.length > 0 && processed < 20) {
                let data = radarQueue.shift(); 
                processed++;
                if (data && data.distance !== undefined) {
                    let msgAngle = data.angle !== undefined ? data.angle : scanAngle;
                    scanAngle = msgAngle;
                    if (data.distance < 400) {
                        addRadarPoint(msgAngle, data.distance);
                        lastDistance = data.distance;
                    } else {
                        lastDistance = 400;
                    }
                    drawScanLine(msgAngle);
                }
            }
            
            drawAllPoints();
            drawLabels();
        }
        
        function drawRadarCircles() {
            noFill();
            stroke(0, 255, 0);
            let stepPx = MAX_RADIUS_PX / 6; 
            for (let i = 1; i <= 6; i++) {
                strokeWeight(i % 2 === 0 ? 3 : 1);
                let currentRadius = stepPx * i;
                circle(x, y, currentRadius * 2); 
            }
        }
        
        function drawScanLine(angle) {
            let usedAngle = angle < 2 * PI ? angle : radians(angle);
            stroke(0, 255, 0);
            strokeWeight(2);
            let displayDist = lastDistance ? map(lastDistance, 0, MAX_RANGE_CM, 0, MAX_RADIUS_PX) : 0;
            displayDist = constrain(displayDist, 0, MAX_RADIUS_PX);
            let x2 = x + cos(usedAngle) * displayDist;
            let y2 = y - sin(usedAngle) * displayDist;
            line(x, y, x2, y2);
        }
        
        function addRadarPoint(angle, distance) {
            let limitedDistance = constrain(distance, 0, MAX_RANGE_CM);
            let radAngle = angle < 2 * PI ? angle : radians(angle);
            let scaledDistance = map(limitedDistance, 0, MAX_RANGE_CM, 0, MAX_RADIUS_PX);
            let px = x + cos(radAngle) * scaledDistance;
            let py = y - sin(radAngle) * scaledDistance;
            points.push({ 
                x: px, 
                y: py, 
                angle: angle, 
                distance: limitedDistance,
                timestamp: millis()
            });
            if (points.length > 500) points.shift();
        }

        function drawAllPoints() {
            let currentTime = millis();
            let fadeDuration = 5000;
            for (let i = points.length - 1; i >= 0; i--) {
                let age = currentTime - points[i].timestamp;
                if (age > fadeDuration) {
                    points.splice(i, 1);
                    continue;
                }
                let opacity = map(age, 0, fadeDuration, 255, 0);
                fill(0, 255, 0, opacity);
                stroke(100, 255, 100, opacity);
                strokeWeight(2);
                circle(points[i].x, points[i].y, 5);
            }
        }
        
        function drawLabels() {
            fill(0, 255, 0);
            noStroke();
            textSize(10);
            textAlign(CENTER, TOP);
            let pxPerMeter = MAX_RADIUS_PX / 3; 
            text("0m", x, y - 10);
            text("1m", x - (pxPerMeter * 1), y - 10);
            text("2m", x - (pxPerMeter * 2), y - 10);
            text("3m", x - MAX_RADIUS_PX, y - 10);
        }
    </script>
</body>
</html>